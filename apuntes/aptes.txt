/**	MINITALK	***/

Funciones:
	◦ ft_printf
	◦ signal: es mas seguro usar sigaction
	◦ sigemptyset (sigset_t *set)
		Crea un conjunto de señales vacio.
	◦ sigaddset (sigset_t *set)
		Añade una señal a un conjunto, poniendo a uno el bit correspondiente.
	◦ sigaction (int signum, const struct sigaction *act, struct sigaction *oldact) 
	◦ kill (int pid, int signal)
		Envía una señal a proceso especificado con pid. Si pid = 0 señal es enviada a todos los procesos, excepto los procesos de sistema. Si valor de retorno == 0 llamado es exitoso sino error retorna en errno
	◦ getpid()
		Devuelve el identificador de proceso (PID) del proceso actual.
	◦ malloc
	◦ free
	◦ pause
		Hace que el proceso llamado quede en sleep hasta que una señal sea recibida. Devuelve -1 cuando la señal es atrapada y la señal que la llama, tenga un valor de retorno. En caso de error esta puesto a EINTR 	
	◦ sleep
	◦ usleep
	◦ exit

Señales: SIGUSR1 y SIGUSR2 (definidas por el usuario)

Señales en UNIX:
	Una señal son mensajes enviados por el SO al proceso para notificar un proceso.
	Son asincronas (el proceso no sabe con anticipacion que el evento ocurrira)
	Permiten terminar o cancelar procesos para atender una excepcion

	Manejador de eventos: es el proceso que permite ejecutar el evento que interrumpe, es decir, atender al evento. Un proceso puede especificar un manejador de señales para ser invocado cuando se recibe una señal. Cuando un manejador es invocado para recibir una señal, se dice que atiende la señal. Un proceso puede realizar las siguientes acciones cuando recibe la señal:

-          Proceso puede realizar acción por defecto
-          Proceso puede bloquear la señal (algunas pueden ignorarse)
-          Proceso puede atender señal con un manejador

Manejadores usualmente se ejecutan en el stack del proceso, lo cual implica que el manejador retorna al punto en que la ejecución fue interrumpida.

Después de ejecutar un SIGNAL, si se recibe una señal se efectúa:
1. Se interrumpe la ejecución del proceso
2. Se almacena el estado del proceso en su stack
3. Se ejecuta la función manejadora de la señal
4. Se recupera el estado del proceso

Después de recibir una señal, es necesario volver a prepararse para recibir otra vez la
señal con otro SIGNAL, ya que si no, se puede recibir la señal y mata al proceso

ENVIO DE SEÑALES
	- kill: permte envia señales entre procesos que tienen el mismo identificador PID
		Sig = 9 es la señal SIGKILL, que mata cualquier proceso
	
	Los posibles valores de PID y la acción de kill asociada son:
		pid = 0 Se envía la señal a todos los procesos del mismo grupo pgrp que el proceso emisor.
		pid = -1 Se envía la señal a todos los proceso, salvo 0 idle y 1 init. Necesario ser root.
		pid > 0 Se envía la señal al proceso que tiene este pid.
		pid < -1 Se envía la señal a todos los procesos del grupo pgrp = - pid.

RECEPCION DE SEÑALES

	- sigaction: se emplea para cambiar la acción tomada por un proceso cuando recibe una determinada señal.
		Signum especifica la señal y puede ser cualquiera válida salvo SIGKILL o SIGSTOP.
		Si act no es nulo, la nueva acción para la señal signum se instala como act. Si oldact no es nulo, la acción anterior se guarda en oldact.
		struct sigaction {
			void (*sa_handler)(int);
			void (*sa_sigaction)(int, siginfo_t *, void *);
			sigset_t sa_mask;
			int sa_flags;
			void (*sa_restorer)(void);
		}

** LLAMADAS AL SISTEMA DE SIGSET**
	- sigaddset: añade una señal a un conjunto, poniendo a uno el bit correspondiente.
		extern inline void sigaddset (sigset_t *set, int _sig) {
			unsigned long sig = _sig - 1; /* resta uno a la señal, el indice del vector comienza en cero */
			if (_NSIG_WORDS == 1) /* tamaño de la palabra unsigned long*/
				set->sig[0] |= 1UL << sig;
			else /* ajustar el indice dividiendo por NSIG_BPW bits por palabra */
				set->sig[sig/_NSIG_BPW] |= 1UL << (sig % _NSIG_BPW);
		}
	- sigemptyset: pone a cero todo el conjunto de señales. En el caso general utiliza la instrucción memset para poner ceros en set. Cuando _NSIG_WORDS vale 1 (palabras de 2 bytes) directamente pone a uno.
		extern inline void sigemptyset (sigset_t *set)
		{
			switch (_NSIG_WORDS) {
			default:
				memset(set, 0, sizeof(sigset_t));
				break;
			case 2: set -> sig [1] = 0;
			case 1: set -> sig [0] = 0;
			break;
			}
		}
